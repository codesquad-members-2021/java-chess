## 미션 5 : 체스 판 위치 부여 및 점수 구현하기

- 체스판의 각 칸에 위치를 부여하고 점수를 구현한다.
- 각 기물의 점수를 기준으로 정렬하는 기능을 구현해 본다.

### 1. 기물의 색, 기물의 종류에 따른 enum 구현

- [X] Color enum 필드 추가
    - 3개의 상수 값 존재 : WHITE, BLACK, NOCOLOR

- [X] Type enum 구현
    - 기물의 종류에 대한 enum 추가
    - 클래스 네이밍 변경 : Representation → Type
    - 상수 추가 : NO_PIECE

- [ ] Piece 클래스 내에 enum 위치

  ```java
     public class Piece {
         public enum Color {
              WHITE, BLACK, NOCOLOR;
         }

         public enum Type {
              PAWN, ROOK, KNIGHT, BISHOP, QUEEN, KING, NO_PIECE;
         }
      }
  ```

- [X] 기물의 종류에 따른 식별 문자 관리
    - 식별문자는 소문자만 관리
    - getWhiteRepresentation()
        - 식별자 바로 리턴
    - getBlackRepresentation()
        - Character.toUpperCase() 적용 후 리턴

   ```java
       public enum Type {
       PAWN('p'), [...];
       
           private char representation;
       
           Type(char representation) {
                   this.representation = representation;
           }
       }
       
       public class PieceTest {
           @Test
           public void getRepresentationPerPiece() throws Exception { 
               assertEquals('p', Piece.Type.PAWN.getWhiteRepresentation());
               assertEquals('P', Piece.Type.PAWN.getBlackRepresentation());
           }
       }
   ```

### 2. Piece에 대한 색과 기물에 따라 분리된 팩토리 메소드에서 enum 사용

- [X] Piece의 색과 기물의 종류에 따라 다른 Piece를 생성하는 팩토리 메소드를 구현
- [X] Piece.createBlank() 추가
    - 기물이 존재하지 않는 Piece
  ```java
      import pieces.Piece.Type;

      public class PieceTest {
      @Test
      public void create_piece() {
      verifyPiece(Piece.createWhitePawn(), Piece.createBlackPawn(), Type.PAWN);
      verifyPiece(Piece.createWhiteKnight(), Piece.createBlackKnight(), Type.KNIGHT);
      verifyPiece(Piece.createWhiteRook(), Piece.createBlackRook(), Type.ROOK);
      verifyPiece(Piece.createWhiteBishop(), Piece.createBlackBishop(), Type.BISHOP);
      verifyPiece(Piece.createWhiteQueen(), Piece.createBlackQueen(), Type.QUEEN);
      verifyPiece(Piece.createWhiteKing(), Piece.createBlackKing(), Type.KING);

      Piece blank = Piece.createBlank();
      assertFalse(blank.isWhite());
      assertFalse(blank.isBlack());
      assertEquals(Type.NO_PIECE, blank.getType());
  }
  
      private void verifyPiece(final Piece whitePiece, final Piece blackPiece, final Type type) {
          assertTrue(whitePiece.isWhite());
          assertEquals(type, whitePiece.getType());
          
          assertTrue(blackPiece.isBlack());
          assertEquals(type, blackPiece.getType());
      }
  }
  ```

### 3. 팩토리 메소드 리팩토링

- [ ] Piece 클래스 팩토리 메소드 중복 제거
    - creatWhite(type)과 createBlack(type) 메소드로 중복 제거
    - private으로 추가

### 4. 체스판의 모든 칸을 Piece로 초기화

- [ ] 비어있는 체스 공간을 빈 Piece로 초기화
    - Piece.createBlank() 적용
    - 🤔 (Why?) 왜 비어있는 체스 공간도 Piece로 넣으면 좋은지에 대해 생각해 보자.
        - null 에러 걱정을 하지 않아도 된다.
        - 가변 길이를 지원하는 ArrayList의 단점(체스 보드 구현에서는) 보완 가능. 비어있는 곳을 채워주는 Piece 덕분에 항상 8*8 사이즈를 유지할 수 있다.
    - 🤔 `ArrayList<ArrayList<Piece>>` 자료구조 대신 현재 자료구조 `List<Rank>` 유지
        - `ArrayList<ArrayList<Piece>>` 자료형은 2차원 배열처럼 고정된 길이를 가지고 있지 않다.
        - Board 클래스에서는 열(column, file)에 대한 책임을, Rank 클래스에서는 행(row, file)에 대한 책임을 맡게끔 하면 관리하기 더 쉬워지지 않을까라는 생각
        - '고정된 길이'에 대한 포인트를 얻을 수
          있었다, [Why is an ArrayList of ArrayLists not multidimensional?](https://stackoverflow.com/questions/43860618/why-is-an-arraylist-of-arraylists-not-multidimensional)

### 5. 기물과 색에 해당하는 기물의 개수를 반환

- [ ] 같은 색과 종류를 가진 체스말의 갯수를 셀 수 있는 메소드 구현
    - 매개변수 : 체스말 색, 종류
    - 기물의 개수를 리턴

### 6. 주어진 위치의 기물을 조회

- [ ] 주어진 위치의 기물을 가져오는 메소드를 구현
    - 예를 들어 체스판이 아래와 같은 상황이라면
        - "a8" 체스말 요청 시 검은색 rook 리턴
        - "e1" 체스말 요청 시 흰색 king 리턴
          ```
              RNBQKBNR  8 (rank 8)
              PPPPPPPP  7
              ........  6
              ........  5
              ........  4
              ........  3
              pppppppp  2
              rnbqkbnr  1 (rank 1)
              
              abcdefgh
          ```
- [ ] BoardTest 테스트 클래스에 해당 메소드의 테스트 추가
    ```java
      public class BoardTest {
          private Board board;
  
      @Before
      public void setup() {
          board = new Board();
      }
  
      [...]
  
      @Test
      public void findPiece() throws Exception {
          board.initialize();
              assertEquals(Piece.createBlackRook(), board.findPiece("a8"));
              assertEquals(Piece.createBlackRook(), board.findPiece("h8"));
              assertEquals(Piece.createWhiteRook(), board.findPiece("a1"));
              assertEquals(Piece.createWhiteRook(), board.findPiece("h1"));
          }
      }
    ```

- [ ] 보드의 열(column, file) 파트
    - 열(column, file) 부분이 알파벳 소문자로 되어있음
    - Option 1. 자료형을 Map<Character, Rank>로 바꾼다
    - Option 2. 해당 메소드에서 열 정보를 char 타입 인자로 받아오면 아스키 코드값으로 연산하여 실제 인덱스(위치) 계산
        - 위치를 xy 좌표로 변환하는 작업에 중복이 발생한다면 Position과 같은 클래스를 추가하는 것도 고려해 본다.

### 7. 임의의 기물을 체스판 위에 추가

- [ ] 체스 판 임의의 위치에 기물을 추가할 수 있는 기능
    - 빈 체스 판을 생성한 후 임의의 위치에 기물을 추가할 수 있는 기능을 구현

- [ ] 테스트 메소드 구현
  ```java
      public class BoardTest {
          private Board board;
  
      @Before
      public void setup() {
          board = new Board();
      }
  
      [...]
  
      @Test
      public void move() throws Exception {
          board.initializeEmpty();
  
          String position = "b5";
          Piece piece = Piece.createBlackRook();
          board.move(position, piece);
  
          assertEquals(piece, board.findPiece(position));
          System.out.println(board.showBoard());
          }
      }
    ```
  #### ✨ 구현 힌트
    - 위 기능을 구현하고 테스트하려면 체스 판을 초기화할 때 **기물이 아무 것도 없는 빈 상태의 체스판을 초기화**할 수 있어야 한다.
        - BoardTest에서 @BeforeEach 부분의 initilaize() 호출 부분 제거해야 함.
    - ArrayList에 존재하는 기존의 Piece를 제거하고 새로운 Piece로 변경하는 경우 **set() 메소드**를 활용한다.

  #### ✨ 클래스 추출 제안
    - 위치 값을 처리하는 부분이 계속해서 **중복 로직**으로 발생한다.
    - 위치 값을 처리하는 부분에 **에러가 발생**할 가능성이 많아 보인다.
    - **위치 값을 처리하는 전담 클래스**를 추가하는 것은 어떨까?

### 8. 체스 프로그램 점수 계산하기

- [ ] 현재까지 남아 있는 기물에 따라 점수를 계산
    - 각 기물의 점수 : queen(9), rook(5), bishop(3), king(2.5), pawn(1), King(0)
    - 같은 세로줄에 같은 색의 pawn이 존재 → pawn(0.5)

- [ ] 한 번에 한 쪽의 점수만을 계산
    - 흰색 따로 검은색 따로 계산

- [ ] 테스트 메소드 작성
  ```java
      public class BoardTest {
      private Board board;
  
      @Before
      public void setup() {
          board = new Board();
      }
  
      [...]
  
      @Test
      public void caculcatePoint() throws Exception {
          board.initializeEmpty();
  
          addPiece("b6", Piece.createBlackPawn());
          addPiece("e6", Piece.createBlackQueen());
          addPiece("b8", Piece.createBlackKing());
          addPiece("c8", Piece.createBlackRook());
  
          addPiece("f2", Piece.createWhitePawn());
          addPiece("g2", Piece.createWhitePawn());
          addPiece("e1", Piece.createWhiteRook());
          addPiece("f1", Piece.createWhiteKing());
  
          assertEquals(15.0, board.caculcatePoint(Color.BLACK), 0.01);
          assertEquals(7.0, board.caculcatePoint(Color.WHITE), 0.01);
  
          System.out.println(board.showBoard());
      }
  
      private void addPiece(String position, Piece piece) {
          board.move(position, piece);
      }
  }
  ```

#### ✨ 구현 힌트 및 조언

- 지금까지 구현한 프로그래밍 로직 중 가장 복잡한 요구사항이다. 이와 같이 복잡한 로직을 어떻게 구현할 것인가?
- 단순한 문제에서 점차 복잡한 단계로 구현하도록 설계한다.
- 한 개의 기물이 체스판에 있는 경우부터 시작해 하나씩 기물을 추가하면서 구현해 나간다.
- 마지막 단계는 pawn이 같은 세로 줄에 있는지를 검사하는 로직을 구현함으로써 요구사항을 완료한다.
- 각각의 기물이 점수를 가지도록 구현한다. enum은 클래스와 같이 생성자를 통해 값을 추가할 수 있다.

   ```java
    public enum Type {
    PAWN('p', 1.0),
    ROOK('r', 5.0),
    KNIGHT('n', 2.5),
    BISHOP('b', 3.0),
    QUEEN('q', 9.0),
    KING('k', 0.0),
    NO_PIECE('.', 0.0);

    private char type;
    private double defaultPoint;

    private Type(char type, double defaultPoint) {
        this.type = type;
        this.defaultPoint = defaultPoint;
    }

    public double getDefaultPoint() {
        return defaultPoint;
    }
            
            [...]
}
   ```

### 9. 기물의 점수에 따라 정렬

- [ ] 모든 체스말을 자바 Collection 에 저장
    - Collection 정렬 기능 활용

- [ ] 점수 순으로 정렬
    - 검은색과 흰색 체스말을 구분해서 정렬
    - 점수가 높은 순서로 정렬
    - 낮은 순서로도 정렬

### 리펙토링

- 인터페이스를 적용할 수 있는 부분 → 인터페이스로 추출 → 코드가 더 깔끔해 지는지, 복잡해 지는지 검토
- 단순한 코드를 위해서는 **요구사항을 만족하는 "최소한의 클래스, 메소드, 중복을 없애는 것"** 중요
    
