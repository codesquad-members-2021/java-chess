## 미션 2 요구 사항 정리

1. 체스판을 담당할 객체를 추가한다.
2. 체스판에 앞 단계에서 구현한 Pawn 객체를 추가하고 관리할 수 있도록 구현한다.

### 보드 구현하기

- 체스판을 담당할 클래스인 Board를 추가하고 Board가 여러 개의 Pawn을 저장할 수 있도록 구현한다.
- Board는 Pawn을 추가할 수 있는 기능을 제공해야 하며, 추가한 Pawn은 ArrayList를 통해 관리한다.

---

### Pawn class 변경

- [X]  매개 변수 없는 Pawn 생성자 테스트
    - PawnTest에 색이 없는 Pawn을 생성하는 테스트를 추가한다.
    - 컴파일 에러 확인

```
public class PawnTest {
    @Test
    public void create_기본생성자() throws Exception {
        Pawn pawn = new Pawn();
        assertEquals("white", pawn.getColor());
    }
}
```

- [X]  매개 변수 없는 Pawn 생성자 구현
    - 기본 생성자
        - 흰색(white)의 Pawn을 생성
    - 테스트 통과 확인

### Color 상수화

- [X]  두 색상에 대한 상수(enum) 생성
- [X]  Pawn 클래스에 color 변수 타입 상수로 변경

- 자바에서 상수 구현하는 방법을 잘 모르겠으면 구글 검색에서 "자바 상수"라는 키워드로 검색해 해결한다.

### Board class

- [X]  Board 클래스 추가

- [ field ]

    - (-) ArrayList<Pawn> pawns
    - (-) int numOfPawns

  - [ constructor ]

    - 기본 생성자
        - 초기 상태 : 말이 없는 상태에서 시작한다.

  - [ method ]

    - add(Pawn pawn)
        - Board에 Pawn 추가
    - size()
        - 현재 Board 위에 있는 Pawn 갯수(numOfPawns) 리턴
    - findPawn(int indexOfPawn)
        - index로 특정 pawn을 리턴

### BoardTest class

- [X]  BoardTest 테스트 클래스 추가
    - create() 테스트 메소드
        1. Pawn을 체스 판에 추가할 수 있는 코드를 작성한다.
        2. 흰색 Pawn과 검은색 Pawn을 체스 판에 추가한다.
        3. Pawn을 추가할 때마다 Pawn의 수가 맞는지 확인한다.
        4. 또한 Pawn을 추가할 때마다 목록을 얻어와 추가한 Pawn을 정상적으로 가지는 것을 확인한다.

  ```
  import static org.junit.Assert.*;

  import org.junit.Test;

  import pieces.Pawn;

  public class BoardTest {
      @Test
      public void create() throws Exception {
          Board board = new Board();
          
          Pawn white = new Pawn(Pawn.WHITE_COLOR);
          board.add(white);
          assertEquals(1, board.size());
          assertEquals(white, board.findPawn(0));
          
          Pawn black = new Pawn(Pawn.BLACK_COLOR);
          board.add(black); 
          assertEquals(2, board.size());
          assertEquals(black, board.findPawn(1));
      }
  }

  ```

### 패키지 분리

- [X] chess 패키지
    - Board
    - BoardTest
- [X]  pieces 패키지
    - PawnTest
    - Pawn
- 패키징 순서
    1. 지금까지 구현한 코드를 chess라는 패키지에 묶는다. 만약 컴파일 문제가 발생하면 해결하고 테스트 코드를 실행해 모두 성공하는지 확인한다.
    2. 만약 컴파일 문제가 발생하면 해결하고 테스트 코드를 실행해 모두 성공하는지 확인한다.
        - 패키지가 달라지는 경우 import를 하지 않아 컴파일 에러가 발생할 수 있다.
        - import를 했음에도 불구하고 컴파일 에러가 발생한다면 접근 제어자가 다른 패키지에서 접근할 수 없도록 구현했을 수 있다.
        - 다른 패키지에서 접근하려면 접근 제어자를 public으로 구현해야 한다.

### 추가 테스트

- [X]  Pawn이 아닌 객체를 Board에 추가
    - Pawn 이외의 객체를 추가해 컴파일 에러가 발생하는지 확인한다. 즉, Pawn 이외의 다른 객체를 추가하면 컴파일 에러가 발생하도록 구현해야 한다.
    - Board의 add() 파라미터 타입을 Pawn으로 지정

### 중복 제거

- 지금까지 구현한 코드에서 중복되는 부분이 있는지 확인하고 제거한다.
- 프로덕션 코드 뿐만 아니라 테스트 코드에서도 중복이 발생하는지 확인하고, @Before 애노테이션을 활용해 중복을 제거한다.

### 코드 리뷰

1. assertAll() 활용
    - 연속적으로 assert 테스트를 사용해야할 때, 이전 테스트 결과와 상관없이 아래의 assert 테스트가 정상적으로 실행되도록 한다.
    - 단 assert 테스트 간에 의존성을 가질 필요가 없는 경우에 assertAll() 사용, 의존성을 가져야만 하는 경우는 그대로
    - [참고](https://blog.jetbrains.com/idea/2020/09/writing-tests-with-junit-5/)

2. 경계 조건 설정 시 테스트 메소드 활용
    - edge case(boundary case)에 대해서는 테스트를 통해 미리 방지
    - [assertThatThrownBy](https://www.baeldung.com/assertj-exception-assertion)

3. JUnit5 접근 제어자
    - JUnit5 테스트 메소드와 테스트 클래스 접근제어자가 public일 필요가 없다.

4. 한글 테스트 메소드
    - `@DisplayName`으로 이미 설명해주고 있기 때문에 메소드명은 가급적 영어로

5. `ArrayList<Pawn> pawns = new ArrayList<>()`
    - 접근 제어자 private (값을 안전하게 숨기자)
    - 업캐스팅으로 유연한 코드 만들기 (응집도가 높아진다)

6. 테스트 메소드
    - 테스트 메소드 책임 분리 (동사 단위로 분리)
    - 목적에 맞는 테스트 로직 작성 (굳이 두 색상을 추가해서 확인?)

7. PawnTest 클래스
    - MainTest -> PawnTest 이름 변경
    


