## 1. 보드판 초기화

- 체스판을 초기화하고 초기화한 결과를 화면으로 출력한다.
- 체스판은 8 * 8로 구성되어 있으며, 지금 단계에는 폰(pawn) 기물만 추가한다.
- 검은색 Pawn은 대문자 P, 흰색 Pawn은 소문자 p로 표시한다.

체스판을 초기화하고 출력한 결과는 다음과 같다.

```
........
PPPPPPPP
........
........
........
........
pppppppp
........
코드복사
```

### **메소드 추가**

- Board::initialize()
    - 검은색 폰과 흰색 폰을 각각 8개씩 가지도록 초기화
- Board::print()
    - 현재 체스판의 결과 출력

---

### **Pawn 색에 따른 출력 문자 부여**

- [X] representation 상수 추가
    - Pawn 필드로 추가 (WHITE_REPRESENTATION, BLACK_REPRESENTATION)
    - 검은색 Pawn (대문자 'P'), 흰색 Pawn (소문자 'p')
    - getRepresentation() 구현
    - Pawn을 생성할 때 두 번째 인자로 representation 값을 전달
    - // 일단 여기까지는 상수 String로 해결

**테스트 코드**

```java
public class PawnTest {
    @Test
    public void create_기본생성자() throws Exception {
        Pawn pawn = new Pawn();
        assertEquals(Pawn.WHITE_COLOR, pawn.getColor());
        assertEquals(Pawn.WHITE_REPRESENTATION, pawn.getRepresentation());
    }

    @Test
    public void create() {
        verifyPawn(Pawn.WHITE_COLOR, Pawn.WHITE_REPRESENTATION);
        verifyPawn(Pawn.BLACK_COLOR, Pawn.BLACK_REPRESENTATION);
    }

    void verifyPawn(final String color, final char representation) {
        Pawn pawn = new Pawn(color, representation);
        assertEquals(color, pawn.getColor());
        assertEquals(representation, pawn.getRepresentation());
    }
}
```

- [ ]  다른 방법으로 구현할 수 있는지 검토해 본다.
    - enum 구현
    - 같은 의미를 가진 값이 2개이므로 함께 관리하는 enum을 따로 만들면 좋을 것 같다.

### **initialize() 구현 -** Board 클래스

- [X]  Pawn 생성 및 추가
    - Pawn 색깔별 List 추가
    - Pawn 색깔별로 8개씩 생성 후 board에 추가
    - 기존의 pawns → board로 이름 변경

- [X] StringBuilder 활용
    - ArrayList의 Pawn 열을 순회
    - Pawn들의 값을 합쳐서 출력

- [X]  BoardTest - initialize()
    - 흰색 Pawn 열(row 6)의 결과가 "pppppppp" 인지 검증
    - 검은색 Pawn 열(row 1)의 결과가 "PPPPPPPP"인지를 검증

```java
public class BoardTest {
    @Test
    public void initialize() throws Exception {
        Board board = new Board();
        board.initialize();
        assertEquals("pppppppp", board.getWhitePawnsResult());
        assertEquals("PPPPPPPP", board.getBlackPawnsResult());
    }
}
```

### **Board 클래스 중복 리팩토링**

- Board 클래스의 initialize() 메소드와 출력 결과물을 생성하는 부분에서 많은 중복이 발생한다.
- 중복 코드를 제거하는 리팩토링을 진행한다.
- 중복 코드를 별도의 메소드로 분리한다. 메소드가 한 가지 일만 처리하도록 구현한다.

### **print() 구현 -** Board 클래스

- [X] StringBuilder 활용
    - ArrayList의 전체 내용을 하나의 String으로 합쳐서 반환
- [ ] BoardTest - print()
    - Board.print()에서 반환한 값을 System.out.println으로 출력하고 확인

## **2. 게임 시작 및 종료**

- 체스 게임을 시작하고 종료하는 기능을 추가한다.
- start 라는 명령을 입력하면 체스 게임을 시작하고, 체스판의 현재 상태를 콘솔 화면에 출력한다.
- end 라는 명령을 입력하면 체스 게임을 종료한다.

### **main() 구현**

- [ ] 메인 클래스 생성
    - main() 생성
    - 시작과 종료 기능 제공
- [ ]  사용자 입력
    - Scanner를 활용, 사용자 입력 값 받는다.
    - while을 통해 사용자 입력 값 계속 받을 수 있다.

## **참고 소스**

- 참고용으로만 사용하자.
- [https://github.com/slipp/chessgame/tree/step3-initialize-board](https://github.com/slipp/chessgame/tree/step3-initialize-board)

### **고민**

- BoardTest - print()
    - 요구사항의 '흰색 Pawn과 검은색 Pawn을 생성해 저장하는 List를 추가해 구현'을 맞추면서도 전체 보드를 어떻게 표현할 수 있을까
    - **[solution]** List<Pawn> board 다시 추가
        - (-) Pawn을 처음 생성할 때 board에 한 번, whitePawns 혹은 blackPawns에 한 번 총 두 번을 추가해주어야 한다.
        - (+) board에서는 전체 체스 말들의 위치를 트래킹, whitePawns와 blackPawns는 현재 Pawn들이 살아있는지를 확인하기 위한 용도라면(쓰임이 다르다면) 처음 생성 혹은 삭제해주는
          비용만 생각해주면 되니까 괜찮은 것 같다.
    - List<Pawn> board
        - List<Pawn> 는 빈 자리를 표현해내기 쉽지 않다.
        - **[solution]** Pawn[][] board로 타입 변경
            - (-) 요구사항과 다르다
            - (+) print() 메소드를 실행할 때 편하다
    
